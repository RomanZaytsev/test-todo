# Отчет о внедрении Doctrine ORM и архитектурных решениях

## Введение

В рамках проекта TODO-PHP было выполнено комплексное внедрение Doctrine ORM с последующей оптимизацией архитектуры. Проект изначально использовал прямые MySQLi запросы, которые были заменены на современный ORM с сохранением полной обратной совместимости.

## Цели внедрения

1. **Замена прямых SQL-запросов** на ORM для повышения безопасности и поддерживаемости
2. **Упрощение архитектуры** путем объединения бизнес-логики и сущностей
3. **Оптимизация структуры файлов** проекта
4. **Сохранение полной совместимости** с существующим кодом

## Исходная архитектура

### До внедрения Doctrine:
```
models/
├── User.php          # Модель с бизнес-логикой и MySQLi запросами
├── Session.php       # Модель с бизнес-логикой и MySQLi запросами
└── Task.php          # Модель с бизнес-логикой и MySQLi запросами

controllers/
├── UserController.php
├── TaskController.php
└── ...

views/
└── ...
```

### Проблемы исходной архитектуры:
- Прямые SQL-запросы в моделях
- Отсутствие абстракции данных
- Сложность тестирования
- Риски SQL-инъекций

## Этапы внедрения Doctrine

### Этап 1: Создание конфигурации Doctrine

**Файл: `configs/Doctrine.php`**
```php
<?php
namespace app\configs;

use Doctrine\ORM\Tools\Setup;
use Doctrine\ORM\EntityManager;

class Doctrine
{
    private static $entityManager;

    public static function getEntityManager(): EntityManager
    {
        if (!self::$entityManager) {
            $paths = [__DIR__ . '/../models'];
            $isDevMode = true;

            $dbParams = [
                'driver'   => 'pdo_mysql',
                'host'     => 'mysql',
                'port'     => '3306',
                'dbname'   => 'todo-php',
                'user'     => 'root',
                'password' => 'root',
                'charset'  => 'utf8',
            ];

            $config = Setup::createAnnotationMetadataConfiguration($paths, $isDevMode);
            self::$entityManager = EntityManager::create($dbParams, $config);
        }

        return self::$entityManager;
    }
}
```

**Особенности:**
- Ленивая инициализация EntityManager
- Конфигурация для разработки с автоматической генерацией прокси
- Настройка подключения к MySQL через Docker

### Этап 2: Создание сущностей Doctrine

**Созданные сущности:**
- `models/Entities/User.php` - сущность пользователя
- `models/Entities/Session.php` - сущность сессии
- `models/Entities/Task.php` - сущность задачи

**Пример сущности User:**
```php
/**
 * @ORM\Entity
 * @ORM\Table(name="user")
 */
class User
{
    /**
     * @ORM\Id
     * @ORM\Column(type="integer")
     * @ORM\GeneratedValue
     */
    private $id;

    /**
     * @ORM\Column(type="string", length=255)
     */
    private $name;

    // Геттеры и сеттеры...
}
```

### Этап 3: Создание моделей с бизнес-логикой

**Архитектурное решение:** Разделение на модели (бизнес-логика) и сущности (Doctrine mapping)

**Структура после внедрения:**
```
models/
├── User.php              # Бизнес-логика пользователя
├── Session.php           # Бизнес-логика сессий
├── Task.php              # Бизнес-логика задач
└── Entities/             # Doctrine сущности
    ├── User.php
    ├── Session.php
    └── Task.php

controllers/
├── UserController.php    # Использует models\User
├── TaskController.php    # Использует models\Task
└── ...
```

### Этап 4: Миграция бизнес-логики

**Пример миграции User модели:**

```php
class User
{
    public static function create($params)
    {
        $em = Doctrine::getEntityManager();

        try {
            // Проверяем, существует ли пользователь
            $existingUser = $em->getRepository(UserEntity::class)
                ->findOneBy(['email' => $params['email']]);

            if ($existingUser) {
                return ['status' => 'E-mail busy'];
            }

            $user = new UserEntity();
            $user->setName($params['name']);
            $user->setEmail($params['email']);
            $user->setHash(PasswordHasher::hash($params['password']));

            $em->persist($user);
            $em->flush();

            return [
                'id' => $user->getId(),
                'status' => 'Created',
                'query' => 'INSERT via Doctrine ORM'
            ];
        } catch (\Exception $e) {
            return [
                'status' => 'Ошибка при создании: ' . $e->getMessage()
            ];
        }
    }
}
```

## Архитектурные решения

### Разделение на модели и сущности

**Преимущества выбранного подхода:**

1. **Разделение ответственности:**
   - Модели: бизнес-логика, валидация, преобразование данных
   - Сущности: Doctrine mapping, типизация данных, связи

2. **Обратная совместимость:**
   - Контроллеры продолжают получать массивы
   - Виды работают без изменений
   - Существующий API не нарушен

3. **Гибкость:**
   - Легко изменить ORM в будущем
   - Можно использовать разные стратегии загрузки данных

**Недостатки:**
- Дублирование кода (геттеры/сеттеры в сущностях и моделях)
- Дополнительный слой абстракции
- Сложность навигации между файлами

### Обеспечение совместимости

**Проблема:** Виды и контроллеры ожидают публичные свойства объектов

**Решение:** Магические методы `__get` и `__set`

```php
// В сущностях добавлены магические методы
public function __get($property)
{
    switch ($property) {
        case 'id': return $this->getId();
        case 'name': return $this->getName();
        case 'email': return $this->getEmail();
        case 'hash': return $this->getHash();
        default: return null;
    }
}
```

## Оптимизация архитектуры

### Этап 5: Объединение моделей и сущностей

**Цель:** Убрать лишние классы и упростить архитектуру

**Выполненные действия:**

1. **Перенос бизнес-логики** из моделей в соответствующие сущности
2. **Добавление публичных свойств** для обратной совместимости
3. **Реализация магических методов** для доступа к приватным свойствам
4. **Обновление контроллеров** для работы с объединенными классами
5. **Удаление старых файлов моделей**

**Итоговая структура:**
```
models/
├── User.php              # Объединенный класс (Doctrine + бизнес-логика)
├── Session.php           # Объединенный класс (Doctrine + бизнес-логика)
└── Task.php              # Объединенный класс (Doctrine + бизнес-логика)
```

### Этап 6: Оптимизация структуры файлов

**Перемещение сущностей:**
- `models/Entities/User.php` → `models/User.php`
- `models/Entities/Session.php` → `models/Session.php`
- `models/Entities/Task.php` → `models/Task.php`
- Удаление директории `models/Entities`

**Обновление namespace:**
- Изменен с `app\models\Entities` на `app\models`
- Обновлены все импорты в контроллерах и других файлах

## Проблемы и решения

### Проблема 1: Приватные свойства Doctrine недоступны в видах

**Симптом:** `Fatal error: Cannot access private property User::$name`

**Решение:** Добавлены магические методы `__get` и `__set`

### Проблема 2: Прокси-объекты Doctrine

**Симптом:** Пользователь загружается как прокси, данные недоступны

**Решение:** Добавлена проверка и принудительная загрузка в методе `current()`

```php
if ($user instanceof \Doctrine\ORM\Proxy\Proxy) {
    $em->refresh($user);
}
```

### Проблема 3: Дублирующиеся объявления свойств

**Симптом:** `Fatal error: Cannot redeclare User::$id`

**Решение:** Удалены дублирующиеся публичные свойства, оставлены только приватные с аннотациями Doctrine

### Проблема 4: Устаревшие прокси-файлы

**Симптом:** Doctrine использует старые namespace в прокси

**Решение:** Очистка кэша и пересоздание прокси-файлов

```bash
rm -rf var/cache/doctrine var/proxies
make composer.update
```

## Итоговая структура проекта

```
models/
├── User.php              # Объединенный класс с Doctrine аннотациями и бизнес-логикой
├── Session.php           # Объединенный класс с Doctrine аннотациями и бизнес-логикой
└── Task.php              # Объединенный класс с Doctrine аннотациями и бизнес-логикой

controllers/
├── UserController.php    # Использует app\models\User
├── TaskController.php    # Использует app\models\Task
└── ...

configs/
└── Doctrine.php          # Конфигурация EntityManager

var/
├── cache/doctrine/       # Кэш Doctrine
└── proxies/              # Прокси-классы (генерируются автоматически)
```

## Преимущества внедрения

### Технические преимущества:
1. **Безопасность:** Защита от SQL-инъекций
2. **Производительность:** Оптимизация запросов через QueryBuilder
3. **Поддерживаемость:** Четкое разделение ответственности
4. **Тестируемость:** Легче тестировать компоненты изолированно

### Архитектурные преимущества:
1. **Гибкость:** Легко изменять ORM или базу данных
2. **Масштабируемость:** Поддержка сложных запросов и связей
3. **Стандартизация:** Следование паттернам ORM

## Недостатки внедрения

1. **Сложность:** Дополнительный слой абстракции
2. **Производительность:** Накладные расходы на ORM
3. **Изучение:** Требуется знание Doctrine

## Рекомендации для будущих проектов

### Когда использовать подобный подход:
- Проекты с существующим кодом (legacy)
- Команды с разделением ролей (backend/frontend)
- Требования к абстракции от конкретной ORM
- Сложная бизнес-логика

### Когда использовать упрощенный подход:
- Новые проекты с нуля
- Маленькие команды (1-3 разработчика)
- Простая бизнес-логика
- Когда важна максимальная производительность

## Заключение

Внедрение Doctrine ORM в проект TODO-PHP было выполнено успешно с сохранением полной обратной совместимости. Архитектура была оптимизирована путем объединения моделей и сущностей в единые классы, что упростило структуру проекта и устранило дублирование кода.

Ключевые достижения:
- [x] Замена прямых SQL-запросов на ORM
- [x] Сохранение совместимости с существующим кодом
- [x] Упрощение архитектуры проекта
- [x] Повышение безопасности и поддерживаемости
